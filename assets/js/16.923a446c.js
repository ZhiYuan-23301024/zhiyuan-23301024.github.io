(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{442:function(t,v,_){t.exports=_.p+"assets/img/file-20250915130129327.901635f2.png"},443:function(t,v,_){t.exports=_.p+"assets/img/file-20250915130141550.12146637.png"},444:function(t,v,_){t.exports=_.p+"assets/img/file-20250915130147614.c228a444.png"},445:function(t,v,_){t.exports=_.p+"assets/img/file-20250915150319127.bcacded7.png"},568:function(t,v,_){"use strict";_.r(v);var s=_(2),i=Object(s.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"运行时数据区域"}},[t._v("运行时数据区域")]),t._v(" "),v("p",[v("img",{attrs:{src:_(442),alt:""}})]),t._v(" "),v("h3",{attrs:{id:"程序计数器"}},[t._v("程序计数器")]),t._v(" "),v("p",[t._v("一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器")]),t._v(" "),v("ul",[v("li",[t._v("线程私有")]),t._v(" "),v("li",[t._v("字节码解释器通过改变计数器依次读取字节码指令")]),t._v(" "),v("li",[t._v("在线程切换场景下标记线程")])]),t._v(" "),v("blockquote",[v("p",[t._v("程序计数器是唯一不会出现内存溢出的内存区域\n它的唯一作用是指示解码内容，大小固定")])]),t._v(" "),v("h3",{attrs:{id:"虚拟机栈"}},[t._v("虚拟机栈")]),t._v(" "),v("p",[t._v("除了本地方法以外其余所有的方法都是通过栈调用的")]),t._v(" "),v("p",[t._v("方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。")]),t._v(" "),v("p",[t._v("栈由一个个栈帧组成\n"),v("img",{attrs:{src:_(443),alt:""}})]),t._v(" "),v("ul",[v("li",[v("code",[t._v("局部变量表")])]),t._v(" "),v("li",[v("code",[t._v("操作数栈")]),t._v("-中间计算结果-临时变量")]),t._v(" "),v("li",[v("code",[t._v("动态链接")]),t._v("-将文件常量池里指向其它方法的符号引用转化为在内存地址中的直接引用\n"),v("img",{attrs:{src:_(444),alt:""}}),t._v("\n栈报错")]),t._v(" "),v("li",[t._v("栈溢出？达到最大栈深度")]),t._v(" "),v("li",[t._v("内存溢出？动态拓展栈时无法申请到足够的内存空间")])]),t._v(" "),v("h3",{attrs:{id:"本地方法栈"}},[t._v("本地方法栈")]),t._v(" "),v("p",[t._v("类同虚拟机栈")]),t._v(" "),v("h3",{attrs:{id:"堆"}},[t._v("堆")]),t._v(" "),v("p",[t._v("存放几乎所有的对象实例和数组\n是垃圾处理器管理的主要区域，故而也称GC堆")]),t._v(" "),v("ul",[v("li",[t._v("分代垃圾回收-新生代堆-老年代堆。。。")]),t._v(" "),v("li",[v("img",{attrs:{src:_(445),alt:""}})]),t._v(" "),v("li")])])}),[],!1,null,null,null);v.default=i.exports}}]);